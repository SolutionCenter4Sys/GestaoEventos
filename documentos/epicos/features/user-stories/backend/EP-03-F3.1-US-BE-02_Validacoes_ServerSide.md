# User Story – Backend | Validações Server-Side Completas

**Épico:** EP-03 – Sistema de Inscrições e Participantes  
**Feature:** EP-03-F3.1 – Formulário de Inscrição Público  
**Produto:** Plataforma de Gestão de Eventos | **Versão:** 1.01 | **Data:** 10/02/2026

---

## 1. Identificação

| Campo | Conteúdo |
|-------|----------|
| **ID da US** | EP-03-F3.1-US-BE-02 |
| **Título** | Validações Server-Side Completas |
| **Relacionada a** | EP-03-F3.1-US-FE-02 (Validações Frontend) |
| **Status** | Proposta |

---

## 2. Formato Como / Quero / Para que

**Como** sistema backend  
**Quero** implementar validações server-side robustas (formato, CPF, unicidade, vagas)  
**Para que** integridade dos dados seja garantida mesmo se validações frontend falharem

---

## 3. Descrição

Camada de validações server-side:

1. **Formato de e-mail** (regex RFC 5322)
2. **CPF válido** (algoritmo dígitos verificadores)
3. **Telefone** (10-11 dígitos)
4. **Unicidade** (CPF + evento)
5. **Vagas disponíveis** (capacidade atual < máxima)
6. **reCAPTCHA** (score > 0.5)

**Princípio:** NUNCA confiar em validações apenas do frontend

---

## 4. Critérios de Aceite

- [ ] Validação de e-mail (regex)
- [ ] Validação de CPF (dígitos verificadores, módulo 11)
- [ ] Validação de telefone (10-11 dígitos)
- [ ] Validação de unicidade (query no BD)
- [ ] Validação de vagas (query count)
- [ ] Validação de CAPTCHA (API Google)
- [ ] Mensagens de erro claras e específicas

---

## 5. Implementação

```typescript
class ValidacaoService {
  validarEmail(email: string): boolean {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
  }
  
  validarCPF(cpf: string): boolean {
    const cleaned = cpf.replace(/\D/g, '');
    if (cleaned.length !== 11 || /^(\d)\1+$/.test(cleaned)) return false;
    
    // Validar dígitos verificadores (algoritmo completo)
    let sum = 0;
    for (let i = 0; i < 9; i++) {
      sum += parseInt(cleaned[i]) * (10 - i);
    }
    let digit = 11 - (sum % 11);
    if (digit >= 10) digit = 0;
    if (digit !== parseInt(cleaned[9])) return false;
    
    sum = 0;
    for (let i = 0; i < 10; i++) {
      sum += parseInt(cleaned[i]) * (11 - i);
    }
    digit = 11 - (sum % 11);
    if (digit >= 10) digit = 0;
    return digit === parseInt(cleaned[10]);
  }
  
  validarTelefone(telefone: string): boolean {
    const cleaned = telefone.replace(/\D/g, '');
    return cleaned.length === 10 || cleaned.length === 11;
  }
  
  async validarUnicidade(cpf: string, eventoId: string): Promise<boolean> {
    const existente = await this.inscricaoRepository.findByCPFAndEvento(cpf, eventoId);
    return !existente;
  }
  
  async validarVagasDisponiveis(eventoId: string): Promise<boolean> {
    const vagasDisponiveis = await this.inscricaoRepository.countVagasDisponiveis(eventoId);
    return vagasDisponiveis > 0;
  }
  
  async validarRecaptcha(token: string): Promise<boolean> {
    const response = await fetch('https://www.google.com/recaptcha/api/siteverify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: `secret=${process.env.RECAPTCHA_SECRET}&response=${token}`
    });
    const data = await response.json();
    return data.success && data.score > 0.5;
  }
}
```

---

## 6. Testes

- [ ] CPF válido passa validação
- [ ] CPF inválido falha validação
- [ ] E-mail inválido falha validação
- [ ] CPF duplicado detectado
- [ ] Vagas esgotadas detectadas
- [ ] CAPTCHA score < 0.5 falha

---

*US EP-03-F3.1-US-BE-02 - Fevereiro/2026*
