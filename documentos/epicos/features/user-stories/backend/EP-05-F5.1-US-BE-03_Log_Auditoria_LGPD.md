# User Story – Backend | Log de Auditoria de Acessos (LGPD)

**Épico:** EP-05 – Gestão de Pacientes Modelo  
**Feature:** EP-05-F5.1 – Cadastro de Paciente Modelo  
**Produto:** Plataforma de Gestão de Eventos | **Versão:** 1.01 | **Data:** 10/02/2026

---

## 1. Identificação

| Campo | Conteúdo |
|-------|----------|
| **ID da US** | EP-05-F5.1-US-BE-03 |
| **Título** | Log de Auditoria de Acessos a Dados Sensíveis |
| **Relacionada a** | EP-08-F8.3 (Auditoria e Logs) |
| **Status** | Proposta |

---

## 2. Formato Como / Quero / Para que

**Como** sistema backend  
**Quero** registrar TODOS os acessos a dados de pacientes modelo em log append-only (imutável)  
**Para que** haja auditoria completa para conformidade LGPD Art. 37 (responsabilidade e prestação de contas)

---

## 3. Descrição

Sistema de log de auditoria específico para acessos a dados sensíveis:

**Eventos Auditados:**
- PACIENTE_MODELO_CRIADO
- PACIENTE_MODELO_VISUALIZADO
- PACIENTE_MODELO_EDITADO
- PACIENTE_MODELO_EXCLUIDO
- ACESSO_PACIENTES_MODELO (listagem)
- DOCUMENTOS_PACIENTE_ACESSADOS
- CONSENTIMENTO_REGISTRADO

**Campos do Log:**
- Timestamp (preciso, milissegundos)
- Usuário que acessou (ID + nome + perfil)
- IP de origem
- User Agent
- Ação realizada
- Paciente afetada (ID + nome)
- Evento vinculado

**Características:**
- **Append-only**: Logs nunca são deletados ou editados
- **Retenção**: 5 anos (LGPD Art. 16)
- **Criptografia**: Logs criptografados em repouso
- **Imutabilidade**: Hash da entrada anterior incluído na próxima (blockchain-like)

---

## 4. Critérios de Aceite

- [ ] TODOS os acessos a pacientes modelo são logados
- [ ] Logs incluem: timestamp, usuário, IP, ação, paciente
- [ ] Logs são append-only (imutáveis)
- [ ] Retenção de 5 anos (job automático NÃO deleta esses logs)
- [ ] Endpoint GET /audit-logs/pacientes-modelo (Admin only) para consulta
- [ ] Export de logs em CSV/JSON para auditoria externa
- [ ] Hash da entrada anterior incluído (garantia de integridade)

---

## 5. Implementação (Pseudocódigo)

```typescript
@Injectable()
export class AuditLogPacientesService {
  async log(data: AuditLogEntry): Promise<void> {
    const timestamp = new Date();
    
    // 1. Buscar hash do último log (integridade)
    const ultimoLog = await this.auditLogRepository.findLast();
    const hashAnterior = ultimoLog?.hash || '0000000000000000';
    
    // 2. Criar entrada de log
    const logEntry = {
      timestamp,
      usuario_id: data.usuarioId,
      usuario_nome: data.usuarioNome,
      usuario_perfil: data.usuarioPerfil,
      ip_origem: data.ip,
      user_agent: data.userAgent,
      acao: data.acao,
      paciente_modelo_id: data.pacienteModeloId,
      paciente_modelo_nome: data.pacienteModeloNome,
      evento_id: data.eventoId,
      detalhes: JSON.stringify(data.detalhes),
      hash_anterior: hashAnterior
    };
    
    // 3. Calcular hash desta entrada (integridade)
    const conteudo = JSON.stringify(logEntry);
    const hash = crypto.createHash('sha256').update(conteudo).digest('hex');
    logEntry.hash = hash;
    
    // 4. Inserir no BD (append-only)
    await this.auditLogRepository.insert(logEntry);
    
    // 5. Log estruturado (arquivo)
    logger.info('Auditoria LGPD', {
      tipo: 'PACIENTE_MODELO',
      acao: data.acao,
      usuario: data.usuarioNome,
      paciente: data.pacienteModeloNome,
      timestamp
    });
  }
}

// Uso em outros serviços
async visualizarPaciente(pacienteId: string, usuario: Usuario): Promise<PacienteModelo> {
  const paciente = await this.pacienteRepository.findById(pacienteId);
  
  // LOG DE AUDITORIA
  await this.auditLogPacientes.log({
    acao: 'PACIENTE_MODELO_VISUALIZADO',
    usuarioId: usuario.id,
    usuarioNome: usuario.nome,
    usuarioPerfil: usuario.perfil,
    ip: this.request.ip,
    userAgent: this.request.headers['user-agent'],
    pacienteModeloId: paciente.id,
    pacienteModeloNome: paciente.nome,
    eventoId: paciente.eventoId,
    detalhes: { campos_acessados: ['nome', 'cpf', 'historicoSaude', 'restricoes'] }
  });
  
  return paciente;
}
```

---

## 6. Tabela: audit_log_pacientes_modelo

```sql
CREATE TABLE audit_log_pacientes_modelo (
  id SERIAL PRIMARY KEY,
  timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  usuario_id UUID NOT NULL REFERENCES usuarios(id) ON DELETE RESTRICT,
  usuario_nome VARCHAR(200) NOT NULL,
  usuario_perfil VARCHAR(50) NOT NULL,
  ip_origem VARCHAR(45) NOT NULL,
  user_agent TEXT NOT NULL,
  acao VARCHAR(100) NOT NULL,
  paciente_modelo_id UUID REFERENCES pacientes_modelo(id) ON DELETE RESTRICT,
  paciente_modelo_nome VARCHAR(200),
  evento_id UUID REFERENCES eventos(id) ON DELETE RESTRICT,
  detalhes JSONB NULL,
  hash_anterior VARCHAR(64) NOT NULL,
  hash VARCHAR(64) NOT NULL UNIQUE,
  
  -- Constraints de integridade
  CONSTRAINT log_imutavel CHECK (id IS NOT NULL) -- Nunca pode ser deletado
);

CREATE INDEX idx_audit_log_pm_timestamp ON audit_log_pacientes_modelo(timestamp DESC);
CREATE INDEX idx_audit_log_pm_usuario ON audit_log_pacientes_modelo(usuario_id);
CREATE INDEX idx_audit_log_pm_paciente ON audit_log_pacientes_modelo(paciente_modelo_id);
CREATE INDEX idx_audit_log_pm_acao ON audit_log_pacientes_modelo(acao);

-- Trigger para prevenir DELETE/UPDATE (append-only)
CREATE OR REPLACE FUNCTION prevent_audit_log_modification()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'Logs de auditoria são imutáveis (append-only)';
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_delete_audit_log_pm
BEFORE DELETE ON audit_log_pacientes_modelo
FOR EACH ROW EXECUTE FUNCTION prevent_audit_log_modification();

CREATE TRIGGER prevent_update_audit_log_pm
BEFORE UPDATE ON audit_log_pacientes_modelo
FOR EACH ROW EXECUTE FUNCTION prevent_audit_log_modification();
```

---

## 7. Endpoint de Consulta (Admin Only)

```typescript
@Get('/audit-logs/pacientes-modelo')
@RequireRoles(PerfilUsuario.ADMIN)
async consultarLogsAuditoria(@Query() query: ConsultaAuditLogDto): Promise<any> {
  const { page = 1, limit = 50, pacienteId, usuarioId, acao, dataInicio, dataFim } = query;
  
  const queryBuilder = this.auditLogRepository.createQueryBuilder('log');
  
  if (pacienteId) {
    queryBuilder.andWhere('log.paciente_modelo_id = :pacienteId', { pacienteId });
  }
  
  if (usuarioId) {
    queryBuilder.andWhere('log.usuario_id = :usuarioId', { usuarioId });
  }
  
  if (acao) {
    queryBuilder.andWhere('log.acao = :acao', { acao });
  }
  
  if (dataInicio && dataFim) {
    queryBuilder.andWhere('log.timestamp BETWEEN :dataInicio AND :dataFim', { dataInicio, dataFim });
  }
  
  const [logs, total] = await queryBuilder
    .orderBy('log.timestamp', 'DESC')
    .skip((page - 1) * limit)
    .take(limit)
    .getManyAndCount();
  
  return {
    data: logs,
    meta: { total, page, limit, totalPages: Math.ceil(total / limit) }
  };
}

@Get('/audit-logs/pacientes-modelo/export')
@RequireRoles(PerfilUsuario.ADMIN)
async exportarLogsAuditoria(@Query() query: ConsultaAuditLogDto, @Res() res: Response): Promise<void> {
  const logs = await this.auditLogRepository.findByQuery(query);
  
  // Export CSV
  const csv = this.csvService.toCsv(logs);
  res.setHeader('Content-Type', 'text/csv');
  res.setHeader('Content-Disposition', `attachment; filename=audit-log-pacientes-${Date.now()}.csv`);
  res.send(csv);
}
```

---

## 8. Testes

- [ ] Visualizar paciente registra log de auditoria
- [ ] Editar paciente registra log de auditoria
- [ ] Logs incluem todos os campos obrigatórios
- [ ] Tentativa de DELETE em audit_log falha (trigger)
- [ ] Tentativa de UPDATE em audit_log falha (trigger)
- [ ] Hash da entrada verifica integridade (hash_anterior correto)
- [ ] Endpoint de consulta retorna logs filtrados corretamente
- [ ] Export CSV funciona

---

*US EP-05-F5.1-US-BE-03 - Fevereiro/2026*
