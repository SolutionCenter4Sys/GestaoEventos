# User Story – Backend | Fila de E-mails com Retry

**Épico:** EP-06 – Sistema de Comunicação  
**Feature:** EP-06-F6.2 – Gatilhos Automáticos  
**Produto:** Plataforma de Gestão de Eventos | **Versão:** 1.01 | **Data:** 10/02/2026

---

## 1. Identificação

| Campo | Conteúdo |
|-------|----------|
| **ID da US** | EP-06-F6.2-US-BE-02 |
| **Título** | Fila Assíncrona de E-mails com Retry Automático |
| **Relacionada a** | EP-06-F6.2-US-BE-01 (Motor de Gatilhos) |
| **Status** | Proposta |

---

## 2. Formato Como / Quero / Para que

**Como** sistema backend  
**Quero** fila assíncrona (RabbitMQ, AWS SQS, Azure Queue, ou BullMQ) que processa envios de e-mail em background com retry automático (3 tentativas, backoff exponencial)  
**Para que** envios de e-mail não bloqueiem operações principais e falhas temporárias sejam tratadas automaticamente

---

## 3. Descrição

Sistema de fila com workers que processam envios de e-mail:

**Arquitetura:**
- **Producer**: Gatilhos adicionam jobs à fila
- **Worker**: Processa jobs e envia e-mails via AWS SES/SendGrid
- **Retry**: 3 tentativas com backoff exponencial (1s, 5s, 30s)
- **Dead Letter Queue (DLQ)**: Após 3 falhas, move para DLQ para análise manual
- **Prioridades**: E-mails críticos (senha, 2FA) têm prioridade alta

**Tecnologias Suportadas:**
- **BullMQ** (Node.js + Redis)
- **RabbitMQ** (AMQP)
- **AWS SQS** (cloud-native)
- **Azure Service Bus** (cloud-native)

---

## 4. Critérios de Aceite

**Funcionalidade:**
- [ ] E-mails adicionados à fila não bloqueiam operação (< 10ms)
- [ ] Worker processa jobs em background (assíncrono)
- [ ] Retry automático: 3 tentativas com backoff exponencial (1s, 5s, 30s)
- [ ] Após 3 falhas, job move para Dead Letter Queue (DLQ)
- [ ] Prioridades: Alta (senha, 2FA), Normal (gatilhos), Baixa (marketing)

**Monitoramento:**
- [ ] Dashboard exibe: jobs pendentes, processados, falhados, taxa de envio
- [ ] Alerta se fila > 1000 jobs pendentes
- [ ] Alerta se taxa de falha > 10%
- [ ] Logs estruturados de cada tentativa de envio

**Performance:**
- [ ] Worker processa mínimo 10 emails/segundo
- [ ] Latência de adição à fila < 10ms
- [ ] Suporta picos de 1000+ jobs sem degradação

---

## 5. Exemplo de Implementação (BullMQ)

### Producer (Adicionar à Fila)
```typescript
import { Injectable } from '@nestjs/common';
import { Queue } from 'bullmq';
import { InjectQueue } from '@nestjs/bullmq';

@Injectable()
export class EmailQueueService {
  constructor(
    @InjectQueue('email') private emailQueue: Queue
  ) {}
  
  async add(email: EmailJob): Promise<void> {
    await this.emailQueue.add(
      'send-email',
      email,
      {
        priority: email.prioridade || 2, // 1=Alta, 2=Normal, 3=Baixa
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 1000 // 1s, 5s, 30s
        },
        removeOnComplete: { age: 24 * 3600 }, // Remove após 24h
        removeOnFail: false // Manter falhados para análise
      }
    );
  }
}

interface EmailJob {
  destinatario: string;
  assunto: string;
  corpo: string;
  prioridade?: number;
  gatilhoId?: string;
  metadados?: Record<string, any>;
}
```

### Worker (Processar Fila)
```typescript
import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Job } from 'bullmq';

@Processor('email', {
  concurrency: 10 // 10 workers paralelos
})
export class EmailWorker extends WorkerHost {
  constructor(
    private emailService: EmailService,
    private auditLogService: AuditLogService
  ) {
    super();
  }
  
  async process(job: Job<EmailJob>): Promise<void> {
    const { destinatario, assunto, corpo, gatilhoId, metadados } = job.data;
    
    try {
      // 1. Enviar e-mail via AWS SES/SendGrid
      const result = await this.emailService.send({
        to: destinatario,
        subject: assunto,
        html: corpo
      });
      
      // 2. Log de sucesso
      await this.auditLogService.log({
        tipoEvento: 'EMAIL_ENVIADO',
        destinatario,
        gatilhoId,
        messageId: result.messageId,
        tentativa: job.attemptsMade,
        sucesso: true,
        metadados
      });
      
      console.log(`[EmailWorker] E-mail enviado para ${destinatario} (tentativa ${job.attemptsMade})`);
      
    } catch (error) {
      // 3. Log de falha
      await this.auditLogService.log({
        tipoEvento: 'EMAIL_FALHA',
        destinatario,
        gatilhoId,
        tentativa: job.attemptsMade,
        sucesso: false,
        erro: error.message,
        metadados
      });
      
      console.error(`[EmailWorker] Falha ao enviar e-mail (tentativa ${job.attemptsMade}/${job.opts.attempts}):`, error);
      
      // 4. Re-throw para ativar retry
      throw error;
    }
  }
  
  async onFailed(job: Job<EmailJob>, error: Error): Promise<void> {
    // Após 3 falhas, job vai para DLQ automaticamente
    console.error(`[EmailWorker] Job ${job.id} falhou definitivamente após ${job.attemptsMade} tentativas`, error);
    
    // Enviar alerta para Admin
    await this.emailService.sendAlert({
      to: process.env.ADMIN_EMAIL,
      subject: 'Alerta: E-mail falhou após 3 tentativas',
      text: `E-mail para ${job.data.destinatario} falhou após 3 tentativas. Erro: ${error.message}`
    });
  }
}
```

---

## 6. Tabela: email_queue_log

```sql
CREATE TABLE email_queue_log (
  id SERIAL PRIMARY KEY,
  job_id VARCHAR(100),
  destinatario VARCHAR(255) NOT NULL,
  assunto TEXT NOT NULL,
  gatilho_id UUID REFERENCES gatilhos_config(id),
  message_id VARCHAR(255) NULL,        -- ID do e-mail no provedor (AWS SES, etc.)
  tentativa INT NOT NULL,
  sucesso BOOLEAN NOT NULL,
  erro TEXT NULL,
  metadados JSONB NULL,
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_email_queue_log_destinatario ON email_queue_log(destinatario);
CREATE INDEX idx_email_queue_log_timestamp ON email_queue_log(timestamp DESC);
CREATE INDEX idx_email_queue_log_gatilho ON email_queue_log(gatilho_id);
CREATE INDEX idx_email_queue_log_sucesso ON email_queue_log(sucesso);
```

---

## 7. Configuração Redis (BullMQ)

```typescript
// app.module.ts
import { BullModule } from '@nestjs/bullmq';

@Module({
  imports: [
    BullModule.forRoot({
      connection: {
        host: process.env.REDIS_HOST,
        port: parseInt(process.env.REDIS_PORT),
        password: process.env.REDIS_PASSWORD
      }
    }),
    BullModule.registerQueue({
      name: 'email'
    })
  ]
})
export class AppModule {}
```

---

## 8. Dashboard de Monitoramento

**Métricas Prometheus:**
```typescript
import { Counter, Gauge } from 'prom-client';

const emailsSentTotal = new Counter({
  name: 'emails_sent_total',
  help: 'Total de e-mails enviados',
  labelNames: ['status'] // success | failed
});

const emailsQueueSize = new Gauge({
  name: 'emails_queue_size',
  help: 'Quantidade de e-mails na fila',
  labelNames: ['state'] // waiting | active | completed | failed
});

// Atualizar métricas periodicamente
setInterval(async () => {
  const counts = await emailQueue.getJobCounts();
  emailsQueueSize.set({ state: 'waiting' }, counts.waiting);
  emailsQueueSize.set({ state: 'active' }, counts.active);
  emailsQueueSize.set({ state: 'completed' }, counts.completed);
  emailsQueueSize.set({ state: 'failed' }, counts.failed);
}, 10000); // A cada 10s
```

---

## 9. Testes

- [ ] Job adicionado à fila não bloqueia operação (< 10ms)
- [ ] Worker processa job e envia e-mail via AWS SES
- [ ] Simular falha temporária, verificar retry automático
- [ ] Após 3 falhas, job move para DLQ
- [ ] Log registra tentativa, sucesso/falha, messageId
- [ ] Prioridade alta (senha) processa antes de normal (gatilhos)
- [ ] Worker processa 10+ emails/segundo

---

*US EP-06-F6.2-US-BE-02 - Fevereiro/2026*
