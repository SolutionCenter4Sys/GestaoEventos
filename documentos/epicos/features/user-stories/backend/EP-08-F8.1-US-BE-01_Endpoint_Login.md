# User Story – Backend – Endpoint de Login

**Épico:** EP-08 – Controle de Acesso e Segurança  
**Feature:** EP-08-F8.1 – Sistema de Autenticação  
**Produto:** Plataforma de Gestão de Eventos  
**Versão:** 1.01  
**Data:** 10/02/2026

---

## 1. Identificação

| Campo | Conteúdo |
|-------|----------|
| **ID da US** | EP-08-F8.1-US-BE-01 |
| **Título** | Endpoint de Login com Validação Bcrypt e JWT |
| **Épico** | EP-08 – Controle de Acesso e Segurança |
| **Feature** | EP-08-F8.1 – Sistema de Autenticação |
| **Relacionada a** | EP-08-F8.1-US-FE-01 (Tela de Login) |
| **Status** | Proposta |

---

## 2. Formato Como / Quero / Para que

| Campo | Conteúdo |
|-------|----------|
| **Como** | Sistema backend / API de autenticação |
| **Quero** | Expor endpoint POST /auth/login que valide credenciais (bcrypt), verifique 2FA se habilitado, gere JWT/refresh token, registre log de tentativa, e aplique rate limiting |
| **Para que** | O frontend possa autenticar usuários de forma segura, retornar tokens de acesso e dados do usuário autenticado |

---

## 3. Descrição

Esta US de backend cobre o endpoint central de autenticação:

- **POST /auth/login** – Autentica usuário com e-mail e senha
- **Validação de senha** usando bcrypt (compare hash armazenado)
- **Geração de tokens JWT** (access token + refresh token) com expiração configurável
- **Verificação de 2FA** se habilitado (exige código TOTP no payload)
- **Rate limiting** para prevenir força bruta (5 tentativas em 15 min)
- **Logging de auditoria** (sucesso e falhas)
- **Regras de negócio:**
  - E-mail deve existir no banco de dados
  - Conta não pode estar inativa/bloqueada
  - Senha deve corresponder ao hash bcrypt
  - Se 2FA ativo, código TOTP deve ser válido
  - Após 5 falhas, bloquear conta por 15 minutos

---

## 4. Serviços / Endpoints

| Serviço / Endpoint | Método | Descrição breve | Tamanho (P/M/G) |
|--------------------|--------|-----------------|-----------------|
| /auth/login | POST | Autentica usuário, retorna JWT + dados do usuário | M |

---

## 5. Contrato de API (prévia)

### Request Body:
```json
{
  "email": "usuario@exemplo.com",
  "senha": "SenhaSegura123",
  "codigoTOTP": "123456"  // Opcional, apenas se 2FA habilitado
}
```

### Response (200 OK - Sucesso):
```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refreshToken": "c8e2f7a0-3b1d-4e9a-a5c6-7d8e9f0a1b2c",
  "usuario": {
    "id": "uuid-do-usuario",
    "nome": "João Silva",
    "email": "usuario@exemplo.com",
    "perfil": "PROFESSOR",
    "foto": "https://cdn.exemplo.com/foto.jpg"
  },
  "expiresIn": 900  // 15 minutos em segundos
}
```

### Response (401 Unauthorized - Credenciais inválidas):
```json
{
  "statusCode": 401,
  "erro": "CREDENCIAIS_INVALIDAS",
  "mensagem": "E-mail ou senha incorretos.",
  "timestamp": "2026-02-10T14:30:00Z"
}
```

### Response (423 Locked - Conta bloqueada por rate limiting):
```json
{
  "statusCode": 423,
  "erro": "CONTA_BLOQUEADA",
  "mensagem": "Muitas tentativas falhas. Tente novamente em 15 minutos.",
  "tempoRestante": 870,  // Segundos até desbloquear
  "timestamp": "2026-02-10T14:30:00Z"
}
```

### Response (428 Precondition Required - 2FA obrigatório):
```json
{
  "statusCode": 428,
  "erro": "CODIGO_2FA_REQUERIDO",
  "mensagem": "Esta conta requer autenticação de dois fatores.",
  "timestamp": "2026-02-10T14:30:00Z"
}
```

### Response (400 Bad Request - Código 2FA inválido):
```json
{
  "statusCode": 400,
  "erro": "CODIGO_2FA_INVALIDO",
  "mensagem": "Código de autenticação inválido ou expirado.",
  "timestamp": "2026-02-10T14:30:00Z"
}
```

---

## 6. Modelo de Dados

### Tabela: usuarios
```sql
CREATE TABLE usuarios (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  nome VARCHAR(200) NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  senha_hash VARCHAR(255) NOT NULL,  -- bcrypt hash
  perfil VARCHAR(50) NOT NULL,       -- ADMIN, PROFESSOR, etc.
  ativo BOOLEAN DEFAULT true,
  bloqueado_ate TIMESTAMP NULL,
  tentativas_login_falhas INT DEFAULT 0,
  ultima_tentativa_login TIMESTAMP NULL,
  two_factor_habilitado BOOLEAN DEFAULT false,
  two_factor_secret VARCHAR(255) NULL,
  criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  atualizado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_usuarios_email ON usuarios(email);
```

### Tabela: refresh_tokens
```sql
CREATE TABLE refresh_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  usuario_id UUID NOT NULL REFERENCES usuarios(id) ON DELETE CASCADE,
  token VARCHAR(500) UNIQUE NOT NULL,
  expira_em TIMESTAMP NOT NULL,
  criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  revogado BOOLEAN DEFAULT false
);

CREATE INDEX idx_refresh_tokens_usuario ON refresh_tokens(usuario_id);
CREATE INDEX idx_refresh_tokens_token ON refresh_tokens(token);
```

### Tabela: logs_autenticacao
```sql
CREATE TABLE logs_autenticacao (
  id SERIAL PRIMARY KEY,
  usuario_id UUID REFERENCES usuarios(id) ON DELETE SET NULL,
  email VARCHAR(255) NOT NULL,
  tipo_evento VARCHAR(50) NOT NULL,  -- LOGIN_SUCESSO, LOGIN_FALHA, LOGOUT
  ip_origem VARCHAR(45) NOT NULL,
  user_agent TEXT,
  sucesso BOOLEAN NOT NULL,
  motivo_falha VARCHAR(255) NULL,   -- SENHA_INCORRETA, CONTA_BLOQUEADA, etc.
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_logs_autenticacao_usuario ON logs_autenticacao(usuario_id);
CREATE INDEX idx_logs_autenticacao_timestamp ON logs_autenticacao(timestamp DESC);
```

---

## 7. Critérios de Aceite

### Funcionalidade:
- [ ] POST /auth/login aceita payload com email, senha, e codigoTOTP (opcional)
- [ ] Senha é validada usando bcrypt.compare(senhaFornecida, senhaHashBD)
- [ ] Se credenciais válidas, gera JWT access token (exp: 15 min) e refresh token (exp: 7 dias)
- [ ] JWT contém claims: sub (userId), email, perfil, iat, exp
- [ ] Refresh token é armazenado na tabela refresh_tokens
- [ ] Response retorna accessToken, refreshToken, usuario, expiresIn
- [ ] Se 2FA habilitado, valida código TOTP antes de gerar tokens
- [ ] Se código 2FA inválido, retorna 400
- [ ] Rate limiting: após 5 tentativas falhas em 15 min, retorna 423 por 15 min
- [ ] Logs de autenticação registram TODAS as tentativas (sucesso/falha)

### Validações:
- [ ] E-mail é obrigatório e formato válido
- [ ] Senha é obrigatória
- [ ] Se usuário não existe, retorna 401 genérico (não revela inexistência por segurança)
- [ ] Se usuário inativo (ativo=false), retorna 401 "Conta inativa"
- [ ] Se usuário bloqueado (bloqueado_ate > now()), retorna 423

### Segurança:
- [ ] Senhas NUNCA são logadas ou retornadas em responses
- [ ] Mensagens de erro genéricas para 401 (não revela se e-mail existe)
- [ ] JWT assinado com secret forte (min 256 bits) armazenado em variável de ambiente
- [ ] Refresh token aleatório (UUID v4 ou crypto.randomBytes)
- [ ] Rate limiting usa Redis (ou in-memory cache se Redis indisponível)

### Performance:
- [ ] Query de usuário por e-mail usa índice (idx_usuarios_email)
- [ ] Bcrypt.compare executa em < 100ms (cost factor adequado: 10-12)
- [ ] Endpoint responde em < 200ms em 95% dos casos (exceto bcrypt)

### Observabilidade:
- [ ] Log estruturado (JSON) com campos: timestamp, level, message, email, ip, sucesso
- [ ] Métricas: contador de logins (sucesso/falha), latência do endpoint
- [ ] Alerta se taxa de falha > 50% em 5 min (possível ataque)

---

## 8. Dependências e Observações

### Dependências:
- **Banco de dados:** PostgreSQL (tabelas usuarios, refresh_tokens, logs_autenticacao)
- **Bibliotecas:**
  - bcrypt ou bcryptjs (hashing de senhas)
  - jsonwebtoken (geração/validação JWT)
  - speakeasy (validação TOTP para 2FA)
  - express-rate-limit ou similar (rate limiting)
- **Cache:** Redis (para rate limiting distribuído) ou in-memory cache
- **Environment vars:** JWT_SECRET, JWT_EXPIRES_IN, REFRESH_TOKEN_EXPIRES_IN

### Observações:
- **Salt rounds bcrypt:** 10-12 (balanço entre segurança e performance)
- **JWT algorithm:** HS256 (HMAC SHA-256) - considerar RS256 para maior segurança em produção
- **Rate limiting:** Implementar por IP + e-mail combinados para prevenir ataques distribuídos
- **2FA:** Usar biblioteca speakeasy ou similar que implementa RFC 6238 (TOTP)
- **Refresh token rotation:** Considerar implementar rotação de refresh token para segurança adicional

---

## 9. Exemplo de Implementação (Pseudocódigo)

```typescript
// POST /auth/login
async function loginHandler(req: Request, res: Response) {
  const { email, senha, codigoTOTP } = req.body;
  const ipOrigem = req.ip;
  const userAgent = req.headers['user-agent'];
  
  // 1. Validar input
  if (!email || !senha) {
    return res.status(400).json({ erro: 'E-mail e senha são obrigatórios' });
  }
  
  // 2. Verificar rate limiting
  const tentativasRecentes = await rateLimiter.check(ipOrigem, email);
  if (tentativasRecentes >= 5) {
    await logAutenticacao(null, email, 'LOGIN_FALHA', ipOrigem, false, 'RATE_LIMIT_EXCEDIDO');
    return res.status(423).json({
      erro: 'CONTA_BLOQUEADA',
      mensagem: 'Muitas tentativas falhas. Tente novamente em 15 minutos.',
      tempoRestante: rateLimiter.getTempoRestante(ipOrigem, email)
    });
  }
  
  // 3. Buscar usuário por e-mail
  const usuario = await usuarioRepository.findByEmail(email);
  if (!usuario) {
    await rateLimiter.increment(ipOrigem, email);
    await logAutenticacao(null, email, 'LOGIN_FALHA', ipOrigem, false, 'EMAIL_NAO_ENCONTRADO');
    return res.status(401).json({ erro: 'CREDENCIAIS_INVALIDAS', mensagem: 'E-mail ou senha incorretos.' });
  }
  
  // 4. Verificar se conta está ativa
  if (!usuario.ativo) {
    await logAutenticacao(usuario.id, email, 'LOGIN_FALHA', ipOrigem, false, 'CONTA_INATIVA');
    return res.status(401).json({ erro: 'CONTA_INATIVA', mensagem: 'Conta inativa. Contate o administrador.' });
  }
  
  // 5. Verificar se está bloqueada temporariamente
  if (usuario.bloqueadoAte && usuario.bloqueadoAte > new Date()) {
    await logAutenticacao(usuario.id, email, 'LOGIN_FALHA', ipOrigem, false, 'CONTA_BLOQUEADA_TEMPORARIAMENTE');
    return res.status(423).json({ erro: 'CONTA_BLOQUEADA', mensagem: 'Conta bloqueada temporariamente.' });
  }
  
  // 6. Validar senha com bcrypt
  const senhaValida = await bcrypt.compare(senha, usuario.senhaHash);
  if (!senhaValida) {
    await rateLimiter.increment(ipOrigem, email);
    await usuarioRepository.incrementTentativaFalha(usuario.id);
    await logAutenticacao(usuario.id, email, 'LOGIN_FALHA', ipOrigem, false, 'SENHA_INCORRETA');
    
    // Bloquear temporariamente após 5 falhas
    if (usuario.tentativasLoginFalhas + 1 >= 5) {
      await usuarioRepository.bloquearTemporariamente(usuario.id, 15); // 15 minutos
    }
    
    return res.status(401).json({ erro: 'CREDENCIAIS_INVALIDAS', mensagem: 'E-mail ou senha incorretos.' });
  }
  
  // 7. Verificar 2FA se habilitado
  if (usuario.twoFactorHabilitado) {
    if (!codigoTOTP) {
      return res.status(428).json({ erro: 'CODIGO_2FA_REQUERIDO', mensagem: 'Esta conta requer autenticação de dois fatores.' });
    }
    
    const totpValido = speakeasy.totp.verify({
      secret: usuario.twoFactorSecret,
      encoding: 'base32',
      token: codigoTOTP,
      window: 1  // Aceita 1 intervalo antes/depois (±30s)
    });
    
    if (!totpValido) {
      await rateLimiter.increment(ipOrigem, email);
      await logAutenticacao(usuario.id, email, 'LOGIN_FALHA', ipOrigem, false, 'CODIGO_2FA_INVALIDO');
      return res.status(400).json({ erro: 'CODIGO_2FA_INVALIDO', mensagem: 'Código de autenticação inválido ou expirado.' });
    }
  }
  
  // 8. Gerar tokens JWT
  const accessToken = jwt.sign(
    {
      sub: usuario.id,
      email: usuario.email,
      perfil: usuario.perfil
    },
    process.env.JWT_SECRET,
    { expiresIn: '15m' }
  );
  
  const refreshToken = crypto.randomUUID();
  await refreshTokenRepository.create({
    usuarioId: usuario.id,
    token: refreshToken,
    expiraEm: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)  // 7 dias
  });
  
  // 9. Resetar contador de tentativas falhas
  await usuarioRepository.resetTentativasFalhas(usuario.id);
  await rateLimiter.reset(ipOrigem, email);
  
  // 10. Log de sucesso
  await logAutenticacao(usuario.id, email, 'LOGIN_SUCESSO', ipOrigem, true, null);
  
  // 11. Retornar resposta
  return res.status(200).json({
    accessToken,
    refreshToken,
    usuario: {
      id: usuario.id,
      nome: usuario.nome,
      email: usuario.email,
      perfil: usuario.perfil,
      foto: usuario.foto
    },
    expiresIn: 900  // 15 minutos em segundos
  });
}
```

---

## 10. Testes

### Testes Unitários:
- [ ] Teste: credenciais válidas sem 2FA retorna 200 + tokens
- [ ] Teste: senha incorreta retorna 401
- [ ] Teste: e-mail inexistente retorna 401 genérico
- [ ] Teste: conta inativa retorna 401
- [ ] Teste: 2FA habilitado sem código retorna 428
- [ ] Teste: 2FA com código inválido retorna 400
- [ ] Teste: 2FA com código válido retorna 200 + tokens
- [ ] Teste: após 5 falhas, conta bloqueada por 15 min
- [ ] Teste: JWT contém claims corretos (sub, email, perfil)
- [ ] Teste: refresh token armazenado no BD

### Testes de Integração:
- [ ] Teste E2E: login completo com credenciais válidas
- [ ] Teste E2E: rate limiting após 5 tentativas
- [ ] Teste E2E: log de auditoria registrado no BD

### Performance:
- [ ] Teste de carga: 100 req/s durante 60s
- [ ] Latência p95 < 300ms (incluindo bcrypt)

---

*US EP-08-F8.1-US-BE-01 - Plataforma de Gestão de Eventos - Fevereiro/2026*
