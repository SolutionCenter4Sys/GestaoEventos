# User Story – Backend – Endpoint de Recuperação de Senha

**Épico:** EP-08 – Controle de Acesso e Segurança  
**Feature:** EP-08-F8.1 – Sistema de Autenticação  
**Produto:** Plataforma de Gestão de Eventos  
**Versão:** 1.01  
**Data:** 10/02/2026

---

## 1. Identificação

| Campo | Conteúdo |
|-------|----------|
| **ID da US** | EP-08-F8.1-US-BE-02 |
| **Título** | Endpoint de Recuperação de Senha (Solicitar + Resetar) |
| **Épico** | EP-08 – Controle de Acesso e Segurança |
| **Feature** | EP-08-F8.1 – Sistema de Autenticação |
| **Relacionada a** | EP-08-F8.1-US-FE-01 (Tela de Recuperação) |
| **Status** | Proposta |

---

## 2. Formato Como / Quero / Para que

| Campo | Conteúdo |
|-------|----------|
| **Como** | Sistema backend / API de autenticação |
| **Quero** | Expor endpoints para solicitar recuperação de senha (POST /auth/recuperar-senha) e resetar senha (PUT /auth/resetar-senha) com token único temporário enviado por e-mail |
| **Para que** | Usuários possam recuperar acesso à conta quando esquecerem a senha, de forma segura (token expira em 1 hora) |

---

## 3. Descrição

Esta US cobre o fluxo completo de recuperação de senha:

- **POST /auth/recuperar-senha** – Gera token único, salva no BD, envia e-mail com link
- **PUT /auth/resetar-senha** – Valida token, atualiza senha (bcrypt hash)
- **Token único:** UUID v4 com expiração de 1 hora
- **E-mail transacional:** Usa serviço de e-mail (AWS SES, SendGrid) com template
- **Segurança:**
  - Token one-time use (marcado como usado após reset)
  - Não revela se e-mail existe (sempre retorna 200 para prevenir enumeração)
  - Link expira em 1 hora
  - Nova senha validada (min 8 caracteres, etc.)

---

## 4. Serviços / Endpoints

| Serviço / Endpoint | Método | Descrição breve | Tamanho (P/M/G) |
|--------------------|--------|-----------------|-----------------|
| /auth/recuperar-senha | POST | Solicita recuperação, gera token, envia e-mail | M |
| /auth/resetar-senha | PUT | Valida token, atualiza senha | M |

---

## 5. Contrato de API

### POST /auth/recuperar-senha

**Request Body:**
```json
{
  "email": "usuario@exemplo.com"
}
```

**Response (200 OK - Sempre, por segurança):**
```json
{
  "mensagem": "Se o e-mail existir em nosso sistema, você receberá um link de recuperação.",
  "expiresIn": 3600
}
```

---

### PUT /auth/resetar-senha

**Request Body:**
```json
{
  "token": "uuid-token-recebido-por-email",
  "novaSenha": "NovaSenhaSegura123"
}
```

**Response (200 OK - Sucesso):**
```json
{
  "mensagem": "Senha atualizada com sucesso! Você já pode fazer login."
}
```

**Response (400 Bad Request - Token inválido/expirado):**
```json
{
  "statusCode": 400,
  "erro": "TOKEN_INVALIDO",
  "mensagem": "Link de recuperação inválido ou expirado. Solicite um novo.",
  "timestamp": "2026-02-10T14:30:00Z"
}
```

**Response (400 Bad Request - Senha fraca):**
```json
{
  "statusCode": 400,
  "erro": "SENHA_FRACA",
  "mensagem": "Senha deve ter no mínimo 8 caracteres, 1 letra maiúscula e 1 número.",
  "timestamp": "2026-02-10T14:30:00Z"
}
```

---

## 6. Modelo de Dados

### Tabela: tokens_recuperacao_senha
```sql
CREATE TABLE tokens_recuperacao_senha (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  usuario_id UUID NOT NULL REFERENCES usuarios(id) ON DELETE CASCADE,
  token VARCHAR(500) UNIQUE NOT NULL,
  criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expira_em TIMESTAMP NOT NULL,
  usado BOOLEAN DEFAULT false,
  usado_em TIMESTAMP NULL,
  ip_solicitacao VARCHAR(45) NULL
);

CREATE INDEX idx_tokens_recuperacao_token ON tokens_recuperacao_senha(token);
CREATE INDEX idx_tokens_recuperacao_usuario ON tokens_recuperacao_senha(usuario_id);
```

---

## 7. Critérios de Aceite

### POST /auth/recuperar-senha:
- [ ] Aceita e-mail válido no payload
- [ ] Se e-mail existe no BD: gera token UUID, salva na tabela com expiração de 1h, envia e-mail
- [ ] Se e-mail NÃO existe: ainda retorna 200 (previne enumeração de usuários)
- [ ] E-mail contém link: `https://plataforma.com/resetar-senha?token=UUID`
- [ ] Token é único e não colide com tokens existentes
- [ ] Rate limiting: max 3 solicitações por e-mail em 1 hora

### PUT /auth/resetar-senha:
- [ ] Valida token: existe, não expirado, não usado
- [ ] Valida nova senha: min 8 chars, 1 maiúscula, 1 número
- [ ] Atualiza senha com bcrypt hash (salt auto)
- [ ] Marca token como usado
- [ ] Invalida TODOS os refresh tokens do usuário (força re-login)
- [ ] Log de auditoria: SENHA_ALTERADA

### Segurança:
- [ ] Token one-time use (usado=true após reset)
- [ ] Token expira em exatamente 1 hora
- [ ] Rate limiting na solicitação
- [ ] E-mail de notificação enviado após reset bem-sucedido

### Observabilidade:
- [ ] Log de solicitação: email, ip, timestamp
- [ ] Log de reset: usuarioId, ip, timestamp
- [ ] Métrica: contador de recuperações (sucesso/falha)

---

## 8. Dependências e Observações

### Dependências:
- **Banco de dados:** PostgreSQL (tabela tokens_recuperacao_senha)
- **Serviço de e-mail:** AWS SES / SendGrid / SMTP
- **Template de e-mail:** HTML com link de recuperação
- **Bibliotecas:** bcrypt, crypto (UUID geração)

### Observações:
- Considerar implementar "forgot password cooldown" (min 5 min entre solicitações)
- Template de e-mail deve ser responsivo e acessível
- Incluir informações de IP e timestamp no e-mail para segurança
- Após 3 tokens não usados, enviar alerta de segurança

---

## 9. Exemplo de Implementação (Pseudocódigo)

```typescript
// POST /auth/recuperar-senha
async function recuperarSenhaHandler(req: Request, res: Response) {
  const { email } = req.body;
  const ipOrigem = req.ip;
  
  // 1. Validar e-mail format
  if (!isValidEmail(email)) {
    return res.status(400).json({ erro: 'E-mail inválido' });
  }
  
  // 2. Rate limiting (3 por hora por e-mail)
  const solicitacoesRecentes = await rateLimiter.check('recuperacao', email);
  if (solicitacoesRecentes >= 3) {
    // Ainda retorna 200 por segurança
    return res.status(200).json({
      mensagem: 'Se o e-mail existir em nosso sistema, você receberá um link de recuperação.',
      expiresIn: 3600
    });
  }
  
  // 3. Buscar usuário (silenciosamente)
  const usuario = await usuarioRepository.findByEmail(email);
  
  if (usuario) {
    // 4. Gerar token único
    const token = crypto.randomUUID();
    const expiraEm = new Date(Date.now() + 60 * 60 * 1000); // 1 hora
    
    // 5. Salvar token no BD
    await tokenRecuperacaoRepository.create({
      usuarioId: usuario.id,
      token,
      expiraEm,
      ipSolicitacao: ipOrigem
    });
    
    // 6. Enviar e-mail
    await emailService.send({
      to: email,
      subject: 'Recuperação de Senha - Plataforma de Gestão de Eventos',
      template: 'recuperacao-senha',
      data: {
        nome: usuario.nome,
        linkRecuperacao: `${process.env.FRONTEND_URL}/resetar-senha?token=${token}`,
        ip: ipOrigem,
        expiraEm: '1 hora'
      }
    });
    
    await rateLimiter.increment('recuperacao', email);
  }
  
  // 7. SEMPRE retorna 200 (segurança)
  return res.status(200).json({
    mensagem: 'Se o e-mail existir em nosso sistema, você receberá um link de recuperação.',
    expiresIn: 3600
  });
}

// PUT /auth/resetar-senha
async function resetarSenhaHandler(req: Request, res: Response) {
  const { token, novaSenha } = req.body;
  const ipOrigem = req.ip;
  
  // 1. Validar input
  if (!token || !novaSenha) {
    return res.status(400).json({ erro: 'Token e nova senha são obrigatórios' });
  }
  
  // 2. Validar força da senha
  if (!isStrongPassword(novaSenha)) {
    return res.status(400).json({
      erro: 'SENHA_FRACA',
      mensagem: 'Senha deve ter no mínimo 8 caracteres, 1 letra maiúscula e 1 número.'
    });
  }
  
  // 3. Buscar token no BD
  const tokenRecuperacao = await tokenRecuperacaoRepository.findByToken(token);
  
  if (!tokenRecuperacao) {
    return res.status(400).json({ erro: 'TOKEN_INVALIDO', mensagem: 'Link de recuperação inválido.' });
  }
  
  // 4. Validar token
  if (tokenRecuperacao.usado) {
    return res.status(400).json({ erro: 'TOKEN_JA_USADO', mensagem: 'Este link já foi utilizado.' });
  }
  
  if (tokenRecuperacao.expiraEm < new Date()) {
    return res.status(400).json({ erro: 'TOKEN_EXPIRADO', mensagem: 'Link expirado. Solicite um novo.' });
  }
  
  // 5. Hash da nova senha
  const senhaHash = await bcrypt.hash(novaSenha, 12);
  
  // 6. Atualizar senha do usuário
  await usuarioRepository.updateSenha(tokenRecuperacao.usuarioId, senhaHash);
  
  // 7. Marcar token como usado
  await tokenRecuperacaoRepository.markAsUsed(token);
  
  // 8. Invalidar todos os refresh tokens (força re-login)
  await refreshTokenRepository.revokeAllByUser(tokenRecuperacao.usuarioId);
  
  // 9. Log de auditoria
  await logAutenticacao(tokenRecuperacao.usuarioId, null, 'SENHA_ALTERADA', ipOrigem, true, null);
  
  // 10. Enviar e-mail de confirmação
  const usuario = await usuarioRepository.findById(tokenRecuperacao.usuarioId);
  await emailService.send({
    to: usuario.email,
    subject: 'Senha Alterada - Plataforma de Gestão de Eventos',
    template: 'senha-alterada-confirmacao',
    data: {
      nome: usuario.nome,
      ip: ipOrigem,
      timestamp: new Date().toISOString()
    }
  });
  
  return res.status(200).json({
    mensagem: 'Senha atualizada com sucesso! Você já pode fazer login.'
  });
}

function isStrongPassword(senha: string): boolean {
  return senha.length >= 8 &&
         /[A-Z]/.test(senha) &&
         /[0-9]/.test(senha);
}
```

---

## 10. Testes

### Testes Unitários:
- [ ] Teste: solicitar recuperação com e-mail existente gera token e envia e-mail
- [ ] Teste: solicitar recuperação com e-mail inexistente retorna 200 (sem gerar token)
- [ ] Teste: resetar senha com token válido atualiza senha
- [ ] Teste: resetar senha com token expirado retorna 400
- [ ] Teste: resetar senha com token usado retorna 400
- [ ] Teste: resetar senha com senha fraca retorna 400
- [ ] Teste: após reset, todos refresh tokens do usuário são revogados

### Testes de Integração:
- [ ] Teste E2E: fluxo completo (solicitar -> receber e-mail -> resetar)
- [ ] Teste: rate limiting bloqueia após 3 solicitações em 1h

---

*US EP-08-F8.1-US-BE-02 - Plataforma de Gestão de Eventos - Fevereiro/2026*
