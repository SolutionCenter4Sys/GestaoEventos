# User Story – Backend – Implementação de 2FA (TOTP)

**Épico:** EP-08 – Controle de Acesso e Segurança  
**Feature:** EP-08-F8.1 – Sistema de Autenticação  
**Produto:** Plataforma de Gestão de Eventos  
**Versão:** 1.01  
**Data:** 10/02/2026

---

## 1. Identificação

| Campo | Conteúdo |
|-------|----------|
| **ID da US** | EP-08-F8.1-US-BE-03 |
| **Título** | Implementação de 2FA (TOTP) com Geração de QR Code |
| **Épico** | EP-08 – Controle de Acesso e Segurança |
| **Feature** | EP-08-F8.1 – Sistema de Autenticação |
| **Relacionada a** | EP-08-F8.1-US-FE-02 (Configuração de 2FA) |
| **Status** | Proposta |

---

## 2. Formato Como / Quero / Para que

| Campo | Conteúdo |
|-------|----------|
| **Como** | Sistema backend / API de autenticação |
| **Quero** | Expor endpoints para habilitar 2FA (gera secret + QR Code), validar código TOTP, e desabilitar 2FA |
| **Para que** | Usuários Admin e Professor possam adicionar camada extra de segurança usando aplicativos autenticadores (Google Authenticator, Authy) |

---

## 3. Descrição

Esta US implementa autenticação de dois fatores usando TOTP (Time-based One-Time Password) conforme RFC 6238:

- **POST /auth/2fa/habilitar** – Gera secret base32, gera QR Code, gera códigos de recuperação
- **POST /auth/2fa/validar** – Valida código TOTP de 6 dígitos, ativa 2FA
- **DELETE /auth/2fa** – Desabilita 2FA (requer senha + código TOTP)
- **GET /auth/2fa/status** – Retorna se 2FA está habilitado

**Segurança:**
- Secret gerado aleatoriamente (32 chars base32)
- QR Code formato: `otpauth://totp/Plataforma:email?secret=SECRET&issuer=Plataforma`
- 10 códigos de recuperação (one-time use)
- Validação com window=1 (aceita ±30s tolerância de relógio)

---

## 4. Serviços / Endpoints

| Serviço / Endpoint | Método | Descrição breve | Tamanho (P/M/G) |
|--------------------|--------|-----------------|-----------------|
| /auth/2fa/status | GET | Retorna status de 2FA do usuário | P |
| /auth/2fa/habilitar | POST | Gera secret, QR Code, códigos recuperação | M |
| /auth/2fa/validar | POST | Valida código TOTP, ativa 2FA | P |
| /auth/2fa | DELETE | Desabilita 2FA | P |

---

## 5. Contrato de API

### GET /auth/2fa/status

**Headers:** Authorization: Bearer {access_token}

**Response (200 OK):**
```json
{
  "habilitado": true,
  "dataHabilitacao": "2026-02-10T14:30:00Z"
}
```

---

### POST /auth/2fa/habilitar

**Headers:** Authorization: Bearer {access_token}

**Response (200 OK):**
```json
{
  "qrCodeDataUrl": "data:image/png;base64,iVBORw0KGgoAAAANS...",
  "secret": "JBSWY3DPEHPK3PXP",
  "codigosRecuperacao": [
    "ABC12-DEF34",
    "GHI56-JKL78",
    "MNO90-PQR12",
    "STU34-VWX56",
    "YZA78-BCD90",
    "EFG12-HIJ34",
    "KLM56-NOP78",
    "QRS90-TUV12",
    "WXY34-ZAB56",
    "CDE78-FGH90"
  ]
}
```

---

### POST /auth/2fa/validar

**Headers:** Authorization: Bearer {access_token}

**Request Body:**
```json
{
  "codigo": "123456"
}
```

**Response (200 OK - Código válido):**
```json
{
  "valido": true,
  "mensagem": "2FA habilitado com sucesso!"
}
```

**Response (400 Bad Request - Código inválido):**
```json
{
  "statusCode": 400,
  "erro": "CODIGO_INVALIDO",
  "mensagem": "Código inválido ou expirado. Verifique o horário do seu dispositivo.",
  "timestamp": "2026-02-10T14:30:00Z"
}
```

---

### DELETE /auth/2fa

**Headers:** Authorization: Bearer {access_token}

**Request Body:**
```json
{
  "senhaAtual": "SenhaSegura123",
  "codigoTOTP": "654321"
}
```

**Response (200 OK - Sucesso):**
```json
{
  "mensagem": "2FA desabilitado com sucesso."
}
```

**Response (401 Unauthorized - Senha incorreta):**
```json
{
  "statusCode": 401,
  "erro": "SENHA_INCORRETA",
  "mensagem": "Senha atual incorreta.",
  "timestamp": "2026-02-10T14:30:00Z"
}
```

---

## 6. Modelo de Dados

### Atualização da Tabela: usuarios
```sql
ALTER TABLE usuarios ADD COLUMN IF NOT EXISTS two_factor_secret VARCHAR(255) NULL;
ALTER TABLE usuarios ADD COLUMN IF NOT EXISTS two_factor_habilitado BOOLEAN DEFAULT false;
ALTER TABLE usuarios ADD COLUMN IF NOT EXISTS two_factor_habilitado_em TIMESTAMP NULL;
```

### Nova Tabela: codigos_recuperacao_2fa
```sql
CREATE TABLE codigos_recuperacao_2fa (
  id SERIAL PRIMARY KEY,
  usuario_id UUID NOT NULL REFERENCES usuarios(id) ON DELETE CASCADE,
  codigo VARCHAR(50) NOT NULL,
  usado BOOLEAN DEFAULT false,
  usado_em TIMESTAMP NULL,
  criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_codigos_recuperacao_usuario ON codigos_recuperacao_2fa(usuario_id);
CREATE INDEX idx_codigos_recuperacao_codigo ON codigos_recuperacao_2fa(codigo);
```

---

## 7. Critérios de Aceite

### POST /auth/2fa/habilitar:
- [ ] Gera secret base32 aleatório (32 caracteres)
- [ ] Secret armazenado NO banco (ainda não ativa 2FA - precisa validar primeiro)
- [ ] Gera QR Code em formato data URL (PNG base64)
- [ ] QR Code contém: `otpauth://totp/Plataforma:email?secret=SECRET&issuer=Plataforma&digits=6&period=30`
- [ ] Gera 10 códigos de recuperação únicos (formato: ABC12-DEF34)
- [ ] Códigos de recuperação armazenados no BD (hasheados ou encriptados)
- [ ] Endpoint requer autenticação (JWT válido)

### POST /auth/2fa/validar:
- [ ] Valida código TOTP de 6 dígitos usando speakeasy ou similar
- [ ] Window=1 (aceita ±30 segundos de tolerância)
- [ ] Se válido: marca `two_factor_habilitado=true` no BD
- [ ] Se inválido: retorna 400 com mensagem clara
- [ ] Log de auditoria: 2FA_HABILITADO

### DELETE /auth/2fa:
- [ ] Requer senha atual + código TOTP válido
- [ ] Valida senha com bcrypt.compare()
- [ ] Valida código TOTP
- [ ] Se válido: remove secret do BD, marca `two_factor_habilitado=false`
- [ ] Deleta todos códigos de recuperação do usuário
- [ ] Log de auditoria: 2FA_DESABILITADO

### GET /auth/2fa/status:
- [ ] Retorna `habilitado` (boolean) e `dataHabilitacao` (timestamp ou null)
- [ ] Endpoint requer autenticação

### Segurança:
- [ ] Secret NUNCA é retornado após habilitação (apenas no POST /habilitar)
- [ ] QR Code expira se não validado em 5 minutos (secret removido)
- [ ] Códigos de recuperação são one-time use
- [ ] Após uso de código de recuperação, gerar novos 10 códigos

### Observabilidade:
- [ ] Log de habilitação/desabilitação de 2FA
- [ ] Métrica: % de usuários com 2FA habilitado (por perfil)
- [ ] Alerta se Admin sem 2FA

---

## 8. Dependências e Observações

### Dependências:
- **Bibliotecas:**
  - speakeasy (geração e validação TOTP)
  - qrcode (geração de QR Code)
- **Banco de dados:** PostgreSQL (colunas em usuarios, tabela codigos_recuperacao_2fa)

### Observações:
- Usar speakeasy.generateSecret() para gerar secret
- QR Code deve ser escaneável por Google Authenticator, Authy, Microsoft Authenticator
- Considerar adicionar notificação por e-mail quando 2FA é habilitado/desabilitado
- Códigos de recuperação devem ser armazenados hasheados (bcrypt) ou encriptados (AES-256)
- Implementar "show secret manually" para usuários que não podem escanear QR Code

---

## 9. Exemplo de Implementação (Pseudocódigo)

```typescript
import speakeasy from 'speakeasy';
import QRCode from 'qrcode';
import crypto from 'crypto';

// POST /auth/2fa/habilitar
async function habilitarTwoFactorHandler(req: Request, res: Response) {
  const usuarioId = req.user.id; // Extraído do JWT
  const usuario = await usuarioRepository.findById(usuarioId);
  
  // 1. Gerar secret
  const secret = speakeasy.generateSecret({
    name: `Plataforma Eventos:${usuario.email}`,
    issuer: 'Plataforma Eventos',
    length: 32
  });
  
  // 2. Gerar QR Code
  const qrCodeDataUrl = await QRCode.toDataURL(secret.otpauth_url);
  
  // 3. Gerar códigos de recuperação
  const codigosRecuperacao = [];
  for (let i = 0; i < 10; i++) {
    const codigo = generateRecoveryCode(); // Ex: "ABC12-DEF34"
    const codigoHash = await bcrypt.hash(codigo, 12);
    
    await codigoRecuperacaoRepository.create({
      usuarioId: usuario.id,
      codigo: codigoHash
    });
    
    codigosRecuperacao.push(codigo);
  }
  
  // 4. Salvar secret (mas NÃO ativar ainda)
  await usuarioRepository.update(usuario.id, {
    twoFactorSecret: secret.base32
  });
  
  // 5. Agendar expiração (5 min) se não validar
  setTimeout(async () => {
    const usuarioAtual = await usuarioRepository.findById(usuario.id);
    if (!usuarioAtual.twoFactorHabilitado && usuarioAtual.twoFactorSecret === secret.base32) {
      await usuarioRepository.update(usuario.id, { twoFactorSecret: null });
      await codigoRecuperacaoRepository.deleteAllByUser(usuario.id);
    }
  }, 5 * 60 * 1000);
  
  return res.status(200).json({
    qrCodeDataUrl,
    secret: secret.base32,
    codigosRecuperacao
  });
}

// POST /auth/2fa/validar
async function validarTOTPHandler(req: Request, res: Response) {
  const { codigo } = req.body;
  const usuarioId = req.user.id;
  const usuario = await usuarioRepository.findById(usuarioId);
  
  // 1. Verificar se tem secret
  if (!usuario.twoFactorSecret) {
    return res.status(400).json({ erro: 'Você precisa habilitar 2FA primeiro.' });
  }
  
  // 2. Validar código TOTP
  const verified = speakeasy.totp.verify({
    secret: usuario.twoFactorSecret,
    encoding: 'base32',
    token: codigo,
    window: 1  // Aceita ±30s
  });
  
  if (!verified) {
    return res.status(400).json({
      erro: 'CODIGO_INVALIDO',
      mensagem: 'Código inválido ou expirado. Verifique o horário do seu dispositivo.'
    });
  }
  
  // 3. Ativar 2FA
  await usuarioRepository.update(usuario.id, {
    twoFactorHabilitado: true,
    twoFactorHabilitadoEm: new Date()
  });
  
  // 4. Log de auditoria
  await logAutenticacao(usuario.id, usuario.email, '2FA_HABILITADO', req.ip, true, null);
  
  // 5. Enviar e-mail de confirmação
  await emailService.send({
    to: usuario.email,
    subject: '2FA Habilitado - Plataforma de Gestão de Eventos',
    template: '2fa-habilitado',
    data: { nome: usuario.nome, ip: req.ip }
  });
  
  return res.status(200).json({
    valido: true,
    mensagem: '2FA habilitado com sucesso!'
  });
}

// DELETE /auth/2fa
async function desabilitarTwoFactorHandler(req: Request, res: Response) {
  const { senhaAtual, codigoTOTP } = req.body;
  const usuarioId = req.user.id;
  const usuario = await usuarioRepository.findById(usuarioId);
  
  // 1. Validar senha atual
  const senhaValida = await bcrypt.compare(senhaAtual, usuario.senhaHash);
  if (!senhaValida) {
    return res.status(401).json({ erro: 'SENHA_INCORRETA', mensagem: 'Senha atual incorreta.' });
  }
  
  // 2. Validar código TOTP
  const verified = speakeasy.totp.verify({
    secret: usuario.twoFactorSecret,
    encoding: 'base32',
    token: codigoTOTP,
    window: 1
  });
  
  if (!verified) {
    return res.status(400).json({ erro: 'CODIGO_INVALIDO', mensagem: 'Código 2FA inválido.' });
  }
  
  // 3. Desabilitar 2FA
  await usuarioRepository.update(usuario.id, {
    twoFactorSecret: null,
    twoFactorHabilitado: false,
    twoFactorHabilitadoEm: null
  });
  
  // 4. Deletar códigos de recuperação
  await codigoRecuperacaoRepository.deleteAllByUser(usuario.id);
  
  // 5. Log de auditoria
  await logAutenticacao(usuario.id, usuario.email, '2FA_DESABILITADO', req.ip, true, null);
  
  // 6. E-mail de notificação
  await emailService.send({
    to: usuario.email,
    subject: '2FA Desabilitado - Plataforma de Gestão de Eventos',
    template: '2fa-desabilitado',
    data: { nome: usuario.nome, ip: req.ip }
  });
  
  return res.status(200).json({
    mensagem: '2FA desabilitado com sucesso.'
  });
}

function generateRecoveryCode(): string {
  const part1 = crypto.randomBytes(2).toString('hex').toUpperCase();
  const part2 = crypto.randomBytes(2).toString('hex').toUpperCase();
  return `${part1}-${part2}`; // Ex: "A3B7-F9E1"
}
```

---

## 10. Testes

### Testes Unitários:
- [ ] Teste: habilitar 2FA gera secret, QR Code e 10 códigos recuperação
- [ ] Teste: validar código TOTP correto ativa 2FA
- [ ] Teste: validar código TOTP incorreto retorna 400
- [ ] Teste: desabilitar 2FA com senha + código corretos funciona
- [ ] Teste: desabilitar 2FA com senha incorreta retorna 401
- [ ] Teste: secret expira se não validado em 5 min

### Testes de Integração:
- [ ] Teste E2E: fluxo completo (habilitar -> validar -> desabilitar)
- [ ] Teste: QR Code escaneável por Google Authenticator real

---

*US EP-08-F8.1-US-BE-03 - Plataforma de Gestão de Eventos - Fevereiro/2026*
