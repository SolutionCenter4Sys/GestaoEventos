# User Story – Backend – Rate Limiting e Logs de Auditoria

**Épico:** EP-08 – Controle de Acesso e Segurança  
**Feature:** EP-08-F8.1 – Sistema de Autenticação  
**Produto:** Plataforma de Gestão de Eventos  
**Versão:** 1.01  
**Data:** 10/02/2026

---

## 1. Identificação

| Campo | Conteúdo |
|-------|----------|
| **ID da US** | EP-08-F8.1-US-BE-04 |
| **Título** | Rate Limiting e Logs de Auditoria de Autenticação |
| **Épico** | EP-08 – Controle de Acesso e Segurança |
| **Feature** | EP-08-F8.1 – Sistema de Autenticação |
| **Relacionada a** | EP-08-F8.1-US-BE-01 (Endpoint de Login), EP-08-F8.3 (Auditoria) |
| **Status** | Proposta |

---

## 2. Formato Como / Quero / Para que

| Campo | Conteúdo |
|-------|----------|
| **Como** | Sistema backend / Middleware de segurança |
| **Quero** | Implementar middleware de rate limiting que bloqueia tentativas de login após 5 falhas em 15 min, e sistema de logging estruturado que registra TODAS as tentativas de autenticação |
| **Para que** | Prevenir ataques de força bruta, detectar atividades suspeitas, e manter auditoria completa para conformidade LGPD (Art. 37) |

---

## 3. Descrição

Esta US implementa camadas críticas de segurança e auditoria:

**Rate Limiting:**
- Middleware que intercepta requests para endpoints de autenticação
- Conta tentativas falhas por IP + e-mail
- Após 5 falhas em 15 minutos: bloqueia por 15 minutos
- Usa Redis para armazenamento distribuído (escala horizontal)
- Fallback para in-memory cache se Redis indisponível

**Logging de Auditoria:**
- Registra TODAS as tentativas de autenticação (sucesso/falha)
- Formato estruturado (JSON) com campos obrigatórios: timestamp, usuarioId, email, ip, userAgent, sucesso, motivoFalha
- Armazenamento: banco de dados (PostgreSQL) + logs estruturados (Winston/Pino)
- Retenção: 12 meses no BD, 3 meses em logs

**Observabilidade:**
- Métricas Prometheus: contador de logins (sucesso/falha), taxa de bloqueio
- Alertas: taxa de falha > 50% em 5 min, tentativas de força bruta detectadas

---

## 4. Serviços / Endpoints

| Serviço / Endpoint | Método | Descrição breve | Tamanho (P/M/G) |
|--------------------|--------|-----------------|-----------------|
| RateLimitMiddleware | Middleware | Intercepta requests, verifica contador, bloqueia se necessário | M |
| AuditLogService | Service | Registra eventos de autenticação no BD e logs | M |

---

## 5. Contrato de API (Rate Limiting)

Quando rate limit é atingido, qualquer endpoint retorna:

**Response (429 Too Many Requests):**
```json
{
  "statusCode": 429,
  "erro": "RATE_LIMIT_EXCEDIDO",
  "mensagem": "Muitas tentativas. Tente novamente em 15 minutos.",
  "tempoRestante": 870,  // Segundos até reset
  "tentativasRestantes": 0,
  "timestamp": "2026-02-10T14:30:00Z"
}
```

**Response Headers:**
```
X-RateLimit-Limit: 5
X-RateLimit-Remaining: 2
X-RateLimit-Reset: 1644513600
Retry-After: 900
```

---

## 6. Modelo de Dados

### Tabela: logs_autenticacao
```sql
CREATE TABLE logs_autenticacao (
  id SERIAL PRIMARY KEY,
  usuario_id UUID REFERENCES usuarios(id) ON DELETE SET NULL,
  email VARCHAR(255) NOT NULL,
  tipo_evento VARCHAR(50) NOT NULL,  -- LOGIN_SUCESSO, LOGIN_FALHA, LOGOUT, 2FA_HABILITADO, etc.
  ip_origem VARCHAR(45) NOT NULL,
  user_agent TEXT,
  pais VARCHAR(2) NULL,              -- ISO 3166-1 alpha-2 (geolocalização IP)
  cidade VARCHAR(100) NULL,
  sucesso BOOLEAN NOT NULL,
  motivo_falha VARCHAR(255) NULL,   -- SENHA_INCORRETA, CONTA_BLOQUEADA, CODIGO_2FA_INVALIDO, etc.
  metadados JSONB NULL,              -- Dados adicionais flexíveis
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_logs_autenticacao_usuario ON logs_autenticacao(usuario_id);
CREATE INDEX idx_logs_autenticacao_email ON logs_autenticacao(email);
CREATE INDEX idx_logs_autenticacao_timestamp ON logs_autenticacao(timestamp DESC);
CREATE INDEX idx_logs_autenticacao_ip ON logs_autenticacao(ip_origem);
CREATE INDEX idx_logs_autenticacao_tipo ON logs_autenticacao(tipo_evento);

-- Índice para consultas de auditoria LGPD
CREATE INDEX idx_logs_autenticacao_auditoria ON logs_autenticacao(usuario_id, timestamp DESC) WHERE sucesso = false;
```

### Redis - Estruturas de Dados

**Contador de tentativas falhas:**
```
KEY: rate_limit:login:{ip}:{email}
VALUE: contador (integer)
TTL: 900 segundos (15 minutos)
```

**Bloqueio temporário:**
```
KEY: rate_limit:blocked:{ip}:{email}
VALUE: timestamp de desbloqueio
TTL: 900 segundos (15 minutos)
```

---

## 7. Critérios de Aceite

### Rate Limiting:
- [ ] Middleware intercepta POST /auth/login e POST /auth/2fa/validar
- [ ] Usa Redis como store principal (chave: `rate_limit:login:{ip}:{email}`)
- [ ] Após 5 tentativas falhas em 15 min: retorna 429 por 15 min
- [ ] Headers X-RateLimit-* são incluídos em TODAS as responses de autenticação
- [ ] Se Redis indisponível, usa in-memory cache (com sync entre instâncias via pub/sub)
- [ ] Whitelist de IPs (admin/dev) não sofre rate limiting
- [ ] Contador reseta após login bem-sucedido

### Logging de Auditoria:
- [ ] TODAS as tentativas de autenticação são logadas (sucesso E falha)
- [ ] Logs incluem: timestamp, usuarioId, email, ip, userAgent, sucesso, motivoFalha
- [ ] Logs armazenados em BD (logs_autenticacao) + arquivo (Winston/Pino)
- [ ] Formato JSON estruturado para fácil parsing
- [ ] Geolocalização de IP (país + cidade) usando MaxMind GeoIP2 ou similar
- [ ] Logs de falha incluem motivo específico: SENHA_INCORRETA, CODIGO_2FA_INVALIDO, CONTA_BLOQUEADA, etc.

### Retenção de Dados (LGPD):
- [ ] Logs no BD retidos por 12 meses
- [ ] Logs em arquivo retidos por 3 meses (rotação diária)
- [ ] Job cron diário: deleta logs > 12 meses
- [ ] Ao deletar usuário (LGPD Art. 18), anonimiza logs (usuario_id = NULL, email = "anonimizado@exemplo.com")

### Observabilidade:
- [ ] Métricas Prometheus:
  - `auth_login_total{status="success|failure"}` (counter)
  - `auth_rate_limit_blocks_total` (counter)
  - `auth_login_duration_seconds` (histogram)
- [ ] Alertas Grafana:
  - Taxa de falha > 50% em 5 min
  - Bloqueios por rate limit > 10 em 1 min (possível ataque)

### Performance:
- [ ] Middleware de rate limiting adiciona < 5ms de latência
- [ ] Insert no BD de log é assíncrono (não bloqueia response)
- [ ] Redis operations usam pipeline para reduzir round-trips

---

## 8. Dependências e Observações

### Dependências:
- **Cache:** Redis (com redis-cluster para HA)
- **Banco de dados:** PostgreSQL (tabela logs_autenticacao)
- **Bibliotecas:**
  - ioredis (cliente Redis)
  - express-rate-limit ou rate-limiter-flexible
  - winston ou pino (logging estruturado)
  - geoip-lite ou @maxmind/geoip2-node (geolocalização IP)
- **Métricas:** prom-client (Prometheus)

### Observações:
- Rate limiting deve ser aplicado por IP + e-mail (não apenas IP, pois atacante pode usar VPN/proxies)
- Considerar implementar CAPTCHA após 3 falhas como camada adicional
- Logs sensíveis (senhas, tokens) NUNCA devem ser registrados
- Implementar endpoint GET /auth/logs (apenas Admin) para consulta de auditoria
- Alertar via e-mail usuário quando login de IP/localização desconhecida

---

## 9. Exemplo de Implementação (Pseudocódigo)

```typescript
import Redis from 'ioredis';
import { RateLimiterRedis } from 'rate-limiter-flexible';
import winston from 'winston';
import geoip from 'geoip-lite';

// --- RATE LIMITING ---

const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

const rateLimiter = new RateLimiterRedis({
  storeClient: redis,
  keyPrefix: 'rate_limit:login',
  points: 5,             // 5 tentativas
  duration: 15 * 60,     // 15 minutos
  blockDuration: 15 * 60 // Bloqueia por 15 min
});

async function rateLimitMiddleware(req: Request, res: Response, next: NextFunction) {
  const ip = req.ip;
  const email = req.body.email || 'unknown';
  const key = `${ip}:${email}`;
  
  try {
    const rateLimiterRes = await rateLimiter.consume(key, 1);
    
    // Adicionar headers
    res.setHeader('X-RateLimit-Limit', 5);
    res.setHeader('X-RateLimit-Remaining', rateLimiterRes.remainingPoints);
    res.setHeader('X-RateLimit-Reset', new Date(Date.now() + rateLimiterRes.msBeforeNext).getTime() / 1000);
    
    next();
  } catch (rejRes) {
    // Rate limit excedido
    res.setHeader('Retry-After', Math.round(rejRes.msBeforeNext / 1000));
    
    return res.status(429).json({
      statusCode: 429,
      erro: 'RATE_LIMIT_EXCEDIDO',
      mensagem: 'Muitas tentativas. Tente novamente em 15 minutos.',
      tempoRestante: Math.round(rejRes.msBeforeNext / 1000),
      tentativasRestantes: 0,
      timestamp: new Date().toISOString()
    });
  }
}

// Aplicar middleware
app.post('/auth/login', rateLimitMiddleware, loginHandler);

// --- LOGGING DE AUDITORIA ---

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ 
      filename: 'logs/autenticacao-error.log', 
      level: 'error' 
    }),
    new winston.transports.File({ 
      filename: 'logs/autenticacao.log' 
    })
  ]
});

class AuditLogService {
  async logAutenticacao(data: {
    usuarioId?: string | null;
    email: string;
    tipoEvento: string;
    ipOrigem: string;
    userAgent?: string;
    sucesso: boolean;
    motivoFalha?: string | null;
  }) {
    const geo = geoip.lookup(data.ipOrigem);
    
    // 1. Log estruturado em arquivo (síncrono - rápido)
    logger.info('Evento de autenticação', {
      usuarioId: data.usuarioId,
      email: data.email,
      tipoEvento: data.tipoEvento,
      ip: data.ipOrigem,
      userAgent: data.userAgent,
      pais: geo?.country,
      cidade: geo?.city,
      sucesso: data.sucesso,
      motivoFalha: data.motivoFalha,
      timestamp: new Date().toISOString()
    });
    
    // 2. Insert no BD (assíncrono - não bloqueia)
    setImmediate(async () => {
      try {
        await db.query(`
          INSERT INTO logs_autenticacao 
          (usuario_id, email, tipo_evento, ip_origem, user_agent, pais, cidade, sucesso, motivo_falha)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        `, [
          data.usuarioId,
          data.email,
          data.tipoEvento,
          data.ipOrigem,
          data.userAgent,
          geo?.country,
          geo?.city,
          data.sucesso,
          data.motivoFalha
        ]);
      } catch (err) {
        logger.error('Erro ao salvar log de auditoria no BD', { erro: err });
      }
    });
    
    // 3. Incrementar métricas Prometheus
    if (data.sucesso) {
      authLoginTotal.labels({ status: 'success' }).inc();
    } else {
      authLoginTotal.labels({ status: 'failure' }).inc();
    }
  }
}

const auditLogService = new AuditLogService();

// Uso no handler de login
async function loginHandler(req: Request, res: Response) {
  const { email, senha } = req.body;
  
  try {
    // ... lógica de autenticação ...
    
    if (senhaValida) {
      await auditLogService.logAutenticacao({
        usuarioId: usuario.id,
        email,
        tipoEvento: 'LOGIN_SUCESSO',
        ipOrigem: req.ip,
        userAgent: req.headers['user-agent'],
        sucesso: true
      });
      
      // Resetar rate limiter
      await rateLimiter.delete(`${req.ip}:${email}`);
      
      return res.status(200).json({ accessToken, ... });
    } else {
      await auditLogService.logAutenticacao({
        usuarioId: usuario.id,
        email,
        tipoEvento: 'LOGIN_FALHA',
        ipOrigem: req.ip,
        userAgent: req.headers['user-agent'],
        sucesso: false,
        motivoFalha: 'SENHA_INCORRETA'
      });
      
      return res.status(401).json({ erro: 'CREDENCIAIS_INVALIDAS', ... });
    }
  } catch (error) {
    logger.error('Erro no handler de login', { erro: error, email, ip: req.ip });
    throw error;
  }
}
```

---

## 10. Métricas Prometheus

```typescript
import { Counter, Histogram } from 'prom-client';

// Contador de logins
const authLoginTotal = new Counter({
  name: 'auth_login_total',
  help: 'Total de tentativas de login',
  labelNames: ['status']  // success | failure
});

// Contador de bloqueios por rate limit
const authRateLimitBlocksTotal = new Counter({
  name: 'auth_rate_limit_blocks_total',
  help: 'Total de bloqueios por rate limiting'
});

// Latência do endpoint de login
const authLoginDuration = new Histogram({
  name: 'auth_login_duration_seconds',
  help: 'Duração do processamento de login',
  buckets: [0.1, 0.2, 0.5, 1, 2, 5]
});
```

---

## 11. Job de Limpeza de Logs (Cron)

```typescript
import cron from 'node-cron';

// Executar diariamente às 2h da manhã
cron.schedule('0 2 * * *', async () => {
  const retencaoMeses = 12;
  const dataLimite = new Date();
  dataLimite.setMonth(dataLimite.getMonth() - retencaoMeses);
  
  try {
    const result = await db.query(`
      DELETE FROM logs_autenticacao 
      WHERE timestamp < $1
    `, [dataLimite]);
    
    logger.info('Job de limpeza de logs executado', {
      registrosDeletados: result.rowCount,
      dataLimite: dataLimite.toISOString()
    });
  } catch (error) {
    logger.error('Erro no job de limpeza de logs', { erro: error });
  }
});
```

---

## 12. Testes

### Testes Unitários:
- [ ] Teste: após 5 falhas, rate limiter bloqueia por 15 min
- [ ] Teste: após login sucesso, contador de rate limit é resetado
- [ ] Teste: headers X-RateLimit-* são incluídos na response
- [ ] Teste: auditLogService registra log no BD e arquivo
- [ ] Teste: geolocalização de IP funciona corretamente

### Testes de Integração:
- [ ] Teste: simular ataque de força bruta (100 requests), verificar bloqueio
- [ ] Teste: logs de auditoria aparecem no BD após login
- [ ] Teste: job de limpeza deleta logs antigos

### Testes de Performance:
- [ ] Teste: rate limiting middleware adiciona < 5ms de latência
- [ ] Teste: insert de log não bloqueia response (assíncrono)

---

*US EP-08-F8.1-US-BE-04 - Plataforma de Gestão de Eventos - Fevereiro/2026*
